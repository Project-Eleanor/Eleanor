"""Alert API endpoints for Eleanor.

Provides CRUD operations for security alerts generated by detection rules.
"""

from datetime import datetime
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.api.v1.auth import get_current_user
from app.database import get_db
from app.models.alert import Alert, AlertSeverity, AlertStatus
from app.models.user import User
from app.services.alert_generator import get_alert_generator

router = APIRouter()


# =============================================================================
# Request/Response Models
# =============================================================================


class AlertResponse(BaseModel):
    """Alert response model."""

    id: UUID
    rule_id: UUID | None
    rule_name: str
    title: str
    description: str | None
    severity: AlertSeverity
    status: AlertStatus
    hit_count: int
    first_seen_at: datetime
    last_seen_at: datetime
    mitre_tactics: list[str]
    mitre_techniques: list[str]
    tags: list[str]
    entities: dict
    case_id: UUID | None
    acknowledged_by: UUID | None
    acknowledged_at: datetime | None
    closed_by: UUID | None
    closed_at: datetime | None
    resolution: str | None
    is_false_positive: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class AlertListResponse(BaseModel):
    """Paginated alert list response."""

    items: list[AlertResponse]
    total: int
    page: int
    page_size: int
    pages: int


class AlertAcknowledgeRequest(BaseModel):
    """Request to acknowledge an alert."""

    pass  # No additional fields needed


class AlertCloseRequest(BaseModel):
    """Request to close an alert."""

    resolution: str = Field(..., min_length=1, max_length=2000)
    is_false_positive: bool = False


class AlertAssignCaseRequest(BaseModel):
    """Request to assign alert to a case."""

    case_id: UUID


class AlertBulkActionRequest(BaseModel):
    """Request for bulk alert actions."""

    alert_ids: list[UUID]
    action: str  # acknowledge, close, assign_case
    case_id: UUID | None = None
    resolution: str | None = None
    is_false_positive: bool = False


# =============================================================================
# Endpoints
# =============================================================================


@router.get("/", response_model=AlertListResponse)
async def list_alerts(
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
    status_filter: AlertStatus | None = Query(None, alias="status"),
    severity: AlertSeverity | None = Query(None),
    rule_id: UUID | None = Query(None),
    case_id: UUID | None = Query(None),
    search: str | None = Query(None),
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=200),
) -> AlertListResponse:
    """List alerts with filtering and pagination."""
    query = select(Alert)

    # Apply filters
    if status_filter:
        query = query.where(Alert.status == status_filter)
    if severity:
        query = query.where(Alert.severity == severity)
    if rule_id:
        query = query.where(Alert.rule_id == rule_id)
    if case_id:
        query = query.where(Alert.case_id == case_id)
    if search:
        search_filter = f"%{search}%"
        query = query.where(
            (Alert.title.ilike(search_filter))
            | (Alert.description.ilike(search_filter))
            | (Alert.rule_name.ilike(search_filter))
        )

    # Count total
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await db.execute(count_query)
    total = total_result.scalar() or 0

    # Pagination
    offset = (page - 1) * page_size
    query = query.offset(offset).limit(page_size).order_by(Alert.last_seen_at.desc())

    result = await db.execute(query)
    alerts = result.scalars().all()

    items = [AlertResponse.model_validate(a) for a in alerts]
    pages = (total + page_size - 1) // page_size if page_size else 1

    return AlertListResponse(
        items=items,
        total=total,
        page=page,
        page_size=page_size,
        pages=pages,
    )


@router.get("/{alert_id}", response_model=AlertResponse)
async def get_alert(
    alert_id: UUID,
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
) -> AlertResponse:
    """Get alert by ID."""
    query = select(Alert).where(Alert.id == alert_id)
    result = await db.execute(query)
    alert = result.scalar_one_or_none()

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found",
        )

    return AlertResponse.model_validate(alert)


@router.get("/{alert_id}/events")
async def get_alert_events(
    alert_id: UUID,
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
    limit: int = Query(100, ge=1, le=1000),
) -> list[dict]:
    """Get events associated with an alert."""
    query = select(Alert).where(Alert.id == alert_id)
    result = await db.execute(query)
    alert = result.scalar_one_or_none()

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found",
        )

    return alert.events[:limit]


@router.post("/{alert_id}/acknowledge", response_model=AlertResponse)
async def acknowledge_alert(
    alert_id: UUID,
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
) -> AlertResponse:
    """Acknowledge an alert."""
    alert_generator = get_alert_generator()
    alert = await alert_generator.acknowledge_alert(alert_id, current_user.id, db)

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found",
        )

    return AlertResponse.model_validate(alert)


@router.post("/{alert_id}/close", response_model=AlertResponse)
async def close_alert(
    alert_id: UUID,
    request: AlertCloseRequest,
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
) -> AlertResponse:
    """Close an alert with resolution."""
    alert_generator = get_alert_generator()
    alert = await alert_generator.close_alert(
        alert_id,
        request.resolution,
        current_user.id,
        db,
        request.is_false_positive,
    )

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found",
        )

    return AlertResponse.model_validate(alert)


@router.post("/{alert_id}/assign-case", response_model=AlertResponse)
async def assign_alert_to_case(
    alert_id: UUID,
    request: AlertAssignCaseRequest,
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
) -> AlertResponse:
    """Assign an alert to a case."""
    query = select(Alert).where(Alert.id == alert_id)
    result = await db.execute(query)
    alert = result.scalar_one_or_none()

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found",
        )

    alert.case_id = request.case_id
    alert.status = AlertStatus.IN_PROGRESS
    alert.updated_at = datetime.utcnow()

    await db.commit()
    await db.refresh(alert)

    return AlertResponse.model_validate(alert)


@router.post("/bulk", response_model=dict)
async def bulk_alert_action(
    request: AlertBulkActionRequest,
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
) -> dict:
    """Perform bulk actions on alerts."""
    alert_generator = get_alert_generator()
    processed = 0
    errors = []

    for alert_id in request.alert_ids:
        try:
            if request.action == "acknowledge":
                await alert_generator.acknowledge_alert(alert_id, current_user.id, db)
            elif request.action == "close":
                if not request.resolution:
                    errors.append({"alert_id": str(alert_id), "error": "Resolution required"})
                    continue
                await alert_generator.close_alert(
                    alert_id,
                    request.resolution,
                    current_user.id,
                    db,
                    request.is_false_positive,
                )
            elif request.action == "assign_case":
                if not request.case_id:
                    errors.append({"alert_id": str(alert_id), "error": "Case ID required"})
                    continue
                query = select(Alert).where(Alert.id == alert_id)
                result = await db.execute(query)
                alert = result.scalar_one_or_none()
                if alert:
                    alert.case_id = request.case_id
                    alert.status = AlertStatus.IN_PROGRESS
            else:
                errors.append({"alert_id": str(alert_id), "error": f"Unknown action: {request.action}"})
                continue
            processed += 1
        except Exception as e:
            errors.append({"alert_id": str(alert_id), "error": str(e)})

    await db.commit()

    return {
        "processed": processed,
        "total": len(request.alert_ids),
        "errors": errors,
    }


@router.delete("/{alert_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_alert(
    alert_id: UUID,
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
) -> None:
    """Delete an alert."""
    query = select(Alert).where(Alert.id == alert_id)
    result = await db.execute(query)
    alert = result.scalar_one_or_none()

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found",
        )

    await db.delete(alert)
    await db.commit()


@router.get("/stats/summary")
async def get_alert_stats(
    db: Annotated[AsyncSession, Depends(get_db)],
    current_user: Annotated[User, Depends(get_current_user)],
) -> dict:
    """Get alert statistics."""
    # Count by status
    status_query = select(Alert.status, func.count(Alert.id)).group_by(Alert.status)
    status_result = await db.execute(status_query)
    status_counts = {row[0].value: row[1] for row in status_result.all()}

    # Count by severity
    severity_query = select(Alert.severity, func.count(Alert.id)).group_by(Alert.severity)
    severity_result = await db.execute(severity_query)
    severity_counts = {row[0].value: row[1] for row in severity_result.all()}

    # Count open alerts
    open_count_query = select(func.count(Alert.id)).where(
        Alert.status.in_([AlertStatus.OPEN, AlertStatus.ACKNOWLEDGED])
    )
    open_result = await db.execute(open_count_query)
    open_count = open_result.scalar() or 0

    return {
        "total_alerts": sum(status_counts.values()),
        "open_alerts": open_count,
        "by_status": status_counts,
        "by_severity": severity_counts,
    }
